# -*- coding: utf-8 -*-import osimport cv2import sysfrom PIL import Imageimport timeimport face_recognitionimport shutilfrom threading import Threadfrom multiprocessing import Queue, PoolStored_face = []Stored_face_name = []known_face_encodings = []known_face_names = []online=''# 多线程，高效读视频class WebcamVideoStream:    def __init__(self, src, width, height):        # initialize the video camera stream and read the first frame        # from the stream        self.stream = cv2.VideoCapture(src)        self.stream.set(cv2.CAP_PROP_FRAME_WIDTH, width)        self.stream.set(cv2.CAP_PROP_FRAME_HEIGHT, height)        (self.grabbed, self.frame) = self.stream.read()        # initialize the variable used to indicate if the thread should        # be stopped        self.stopped = False    def start(self):        # start the thread to read frames from the video stream        Thread(target=self.update, args=()).start()        return self    def update(self):        # keep looping infinitely until the thread is stopped        while True:            # if the thread indicator variable is set, stop the thread            if self.stopped:                return            # otherwise, read the next frame from the stream            (self.grabbed, self.frame) = self.stream.read()    def read(self):        # return the frame most recently read        return self.frame    def stop(self):        # indicate that the thread should be stopped        self.stopped = True#导入所有已知头像def LoadKnownImage():    path = './image'    images = os.listdir(path)    for img in images:        if not os.path.isdir(img):            image = face_recognition.load_image_file(path + '/' + img)            # 导入每张图像特征，存入列表            known_face_encodings.append(face_recognition.face_encodings(image)[0])            # 导入图像名字。            known_face_names.append(img.split('.')[0])#导入预警照片def LoadAlertImages():    path = './alert'    if os.path.isdir('./alert') == False:        os.makedirs('./alert')    images = os.listdir(path)    # 导入已存储的每张图像特征，存入列表    for img in images:        if not os.path.isdir(img):            image = face_recognition.load_image_file(path + '/' + img)            try:                Stored_face.append(face_recognition.face_encodings(image)[0])                Stored_face_name.append(img.split('.')[0] + img.split('.')[1])            except:                print "Load image {} failed".format(img)# 存储入侵者照片并报警# #TODO(luolinhao): 添加邮件报警功能def StoreAndAlert(face_encoding, frame):    # 检查脸是否已经存储，并不超过30分钟    CheckStatus = False    for face, name in zip(Stored_face, Stored_face_name):        matches = face_recognition.compare_faces([face_encoding], face, tolerance=0.45)        if True in matches and (time.time() - float(name) < 1800):            CheckStatus = True            print "ALERT! THIS ONE HAS CAME IN 30 MINUTES"            break    # 如果未存储，或者存储时间超过30分钟    if CheckStatus == False:        if os.path.exists('./alert') == False:            try:                os.makedirs('./alert')            except:                print "Create dir faild"        try:            Time = time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(time.time()))            cv2.imwrite('./alert/' + str(time.time()) + '.jpg', frame)            print "ALERT! SOMEONE COMMING WITHOUT AUTH. HIS IMAGE WAS STORED IN" + './alert/' + str(                time.time()) + '.jpg'            Stored_face.append(face_encoding)            Stored_face_name.append(str(time.time()))        except Exception, e:            print "SOMECON COMMING !!! BUT TAKE PHOTO FAILDcreate file filed"            print e    return#捕捉视频def CatchUsbVideo(window_name, camera_idx):    local=raw_input('Do you want to watch locally? (yes/no): ')    global online    # 打开已知图像    LoadKnownImage()    #打开已存预警照片    LoadAlertImages()    StartTime=time.time()    input_q = Queue()  # 多进程输入队列    output_q = Queue()  # 多进程输出队列    pool = Pool(8, worker, (input_q, output_q,known_face_encodings,known_face_names))  # 多进程加载模型    video_capture = WebcamVideoStream(src=camera_idx,                                      width=1280,                                      height=720).start()    #process_this_frame = True    print "Start monitoring press 'q' to quit"    while True:        frame=video_capture.read()        input_q.put(frame)        frame=output_q.get()        #本地显示        if local=='yes':            cv2.imshow(window_name,frame)        #图像保存在本地用于web监控        if os.path.exists('./cache')==False:            os.makedirs('./cache')        cv2.imwrite('./cache/online.jpg', frame)        if cv2.waitKey(1) & 0xFF == ord('q'):            break    # Release handle to the webcam    pool.terminate()  # 关闭多进程    video_capture.stop()  # 关闭视频流    cv2.destroyAllWindows()  # opencv窗口关闭    return#多进程工作def worker(input_q,output_q,known_face_encodings,known_face_names):    face_locations = []    face_encodings = []    face_names = []    while True:        frame = input_q.get()        # Resize frame of video to 1/4 size for faster face recognition processing        small_frame = cv2.resize(frame, (0, 0), fx=0.25, fy=0.25)        # Convert the image from BGR color (which OpenCV uses) to RGB color (which face_recognition uses)        rgb_small_frame = cv2.cvtColor(small_frame, cv2.COLOR_BGR2RGB)        process_this_frame = True        # Only process every other frame of video to save time        if process_this_frame:            # Find all the faces and face encodings in the current frame of video            face_locations = face_recognition.face_locations(rgb_small_frame)            face_encodings = face_recognition.face_encodings(rgb_small_frame, face_locations)            face_names = []            for face_encoding in face_encodings:                # See if the face is a match for the known face(s)                matches = face_recognition.compare_faces(known_face_encodings, face_encoding, tolerance=0.35)                name = "Unknown"                # If a match was found in known_face_encodings, just use the first one.                if True in matches:                    first_match_index = matches.index(True)                    name = known_face_names[first_match_index]                face_names.append(name)                # 报警                if name == "Unknown":                    StoreAndAlert(face_encoding, frame)        process_this_frame = not process_this_frame        # Display the results        for (top, right, bottom, left), name in zip(face_locations, face_names):            # Scale back up face locations since the frame we detected in was scaled to 1/4 size            top *= 4            right *= 4            bottom *= 4            left *= 4            # Draw a box around the face            cv2.rectangle(frame, (left, top), (right, bottom), (0, 0, 255), 2)            # Draw a label with a name below the face            cv2.rectangle(frame, (left, bottom - 35), (right, bottom), (0, 0, 255), cv2.FILLED)            font = cv2.FONT_HERSHEY_DUPLEX            cv2.putText(frame, name, (left + 6, bottom - 6), font, 1.0, (255, 255, 255), 1)        output_q.put(frame)        # Display the resulting image#拍照def StoreYourPhoto(id):    # cv2.namedWindow('Take a photo',id)    cap = cv2.VideoCapture(id)    print "Press 'c' to take a photo. 'q' to quit"    while cap.isOpened():        # 保存一帧        ok, frame = cap.read()        if not ok:            print "Can not capture picture"            break        # 输出        cv2.imshow('take a photo', frame)        if cv2.waitKey(10) & 0xFF == ord('q'):            cap.release()            cv2.destroyAllWindows()            return        if cv2.waitKey(10) & 0xFF == ord('c'):            name = raw_input('Please input your name:')            if os.path.exists('./image') == False:                try:                    os.makedirs('./image')                except:                    print "Create dir faild"            try:                cv2.imwrite('./image/' + name + '.jpg', frame)                print "success"            except:                print "create file filed"                pass#删除def DelPhotos():    while 1:        name=raw_input('Please input your name:')        path = './image'        if os.path.isdir('./image') == False:            print "No dic"        images = os.listdir(path)        find=False        for i in images:            if name+'.jpg' == i:                find=True                try:                    os.remove(path+'/'+i)                    print "Del {} sucess".format(i)                    return                except Exception,e:                    print "Del failed"        if find==False:            print "Not found"#清空def clear():    print "ARE YOU SURE YOU WANT TO DEL ALL THE PHOTOS IN ALERT ?"    choice=raw_input("Input 'yes' to del:")    if choice == 'yes':        try:            shutil.rmtree("./alert")            os.makedirs("./alert")            global Stored_face            global Stored_face_name            Stored_face [:] = []            Stored_face_name [:] = []            print "Clear success"        except Exception,e:            print e    return#菜单def menu(id):    #app.run(host='0.0.0.0', debug=True, port=5000)    # 菜单    while 1:        print '''        1.Monitor        2.Add your photo        3.Del photo        4.Clear All alert history        6.Quit        '''        Choice = input("please input your choice:")        if Choice == 6:            return        if Choice == 1:            CatchUsbVideo("Watching now", id)        if Choice == 2:            StoreYourPhoto(id)        if Choice== 3:            DelPhotos()        if Choice==4:            clear()if __name__ == '__main__':    i = raw_input('Please input your camer id:')    menu(int(i))